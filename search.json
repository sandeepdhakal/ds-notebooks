[
  {
    "objectID": "notebooks/qld-election-2024-pref-flows.html",
    "href": "notebooks/qld-election-2024-pref-flows.html",
    "title": "Visualising preference flows in 2024 QLD state elections",
    "section": "",
    "text": "I have recently written a dashboard to explore the preference flows of votes during the 2024 QLD state elections. The dashboard is available here.\nThe dashboard has three tabs: 1. Overall preference flows, 2. Preference flows in each electorate, 3. A what-if scenario to test the impact of different levels of preference flows from the Greens to Labor.\nIn this noitebook, I will discuss how I generated the overall preference flow Sankey diagram and a corresponding table."
  },
  {
    "objectID": "notebooks/qld-election-2024-pref-flows.html#preference-count-for-each-electorate",
    "href": "notebooks/qld-election-2024-pref-flows.html#preference-count-for-each-electorate",
    "title": "Visualising preference flows in 2024 QLD state elections",
    "section": "Preference count for each electorate",
    "text": "Preference count for each electorate\nThe first preference votes, preference flows and the final result are all available with a single API call.\n\nhttps://resultsdata.elections.qld.gov.au/SGE2024-preference-count-district-{electorate_stub}.json\n\nLet’s see what it looks like for the Aspley electorate.\n\nfrom string import Template\n\nprefs_url = Template(\n    \"https://resultsdata.elections.qld.gov.au/SGE2024-preference-count-district-$electorate.json\"\n)\nelectorate = \"aspley\"\nres = requests.get(prefs_url.substitute(electorate=electorate))\nresult = res.json()\n\npprint.pp(result, depth=2)\n\n{'contest': 'state',\n 'electorateName': 'Aspley',\n 'countround': 4,\n 'lastUpdated': '2024-11-13T14:43:05.097649+10:00',\n 'totalFormalVotes': 35747,\n 'totalVotes': 35747,\n 'candidates': [{...}, {...}],\n 'totalPrimary': 35747,\n 'preferenceDistributionDetails': {'distributions': [...], 'primary': [...]},\n 'totalExhausted': 0,\n 'totalExhaustedPercentage': '0.00%',\n 'votesRemainingInCount': 35747,\n 'votesRemainingInCountPercentage': '100.00%'}\n\n\nThis json file has a lot of information. So let’s break this down into different chunks.\n\nPrimary votes\nThe primary votes obtained by each candidate are provided as preferenceDistributionDetails &gt; primary. This is a list containing information for each candidate.\n\nresult[\"preferenceDistributionDetails\"][\"primary\"]\n\n[{'ballotName': 'HALL, Allan',\n  'ballotOrderNumber': 1,\n  'party': \"Pauline Hanson's One Nation Queensland Division\",\n  'partyCode': 'One Nation',\n  'primary': 1539},\n {'ballotName': 'CAPELL, Wayne',\n  'ballotOrderNumber': 2,\n  'party': 'Family First Queensland',\n  'partyCode': 'Family First',\n  'primary': 707},\n {'ballotName': 'MELLISH, Bart',\n  'ballotOrderNumber': 3,\n  'party': 'Australian Labor Party (State of Queensland)',\n  'partyCode': 'Australian Labor Party',\n  'primary': 13988},\n {'ballotName': 'COOPER, Amanda',\n  'ballotOrderNumber': 4,\n  'party': 'Liberal National Party of Queensland',\n  'partyCode': 'LNP',\n  'primary': 15696},\n {'ballotName': 'HAWKINS, Fiona',\n  'ballotOrderNumber': 5,\n  'party': 'Queensland Greens',\n  'partyCode': 'The Greens',\n  'primary': 3817}]\n\n\n\n\nFinal tally\nThe final tally is available as the candidates key in the JSON result.\n\nresult[\"candidates\"]\n\n[{'ballotName': 'MELLISH, Bart',\n  'ballotOrderNumber': 3,\n  'party': 'Australian Labor Party (State of Queensland)',\n  'partyCode': 'Australian Labor Party',\n  'count': 17889,\n  'percentage': '50.04%'},\n {'ballotName': 'COOPER, Amanda',\n  'ballotOrderNumber': 4,\n  'party': 'Liberal National Party of Queensland',\n  'partyCode': 'LNP',\n  'count': 17858,\n  'percentage': '49.96%'}]\n\n\n\n\nPreference distributions\nThis contains information about each preference distribution: the excluded candidate, preferences distributed to each remaining candidate, and the new tally of the remaining candidates.\n\npprint.pp(result[\"preferenceDistributionDetails\"][\"distributions\"][0], depth=3)\n\n{'exclusion': 1,\n 'excludedCandidate': 'CAPELL, Wayne',\n 'excludedCandidateBallotOrder': 2,\n 'excludedCandidateParty': 'Family First Queensland',\n 'excludedCandidatePartyCode': 'Family First',\n 'excludedCandidateVotes': 707,\n 'exhausted': 0,\n 'exhaustedPercentage': '0.00%',\n 'totalExhausted': 0,\n 'votesDistributed': 707,\n 'votesRemainingInCount': 35747,\n 'preferences': [{'ballotName': 'HALL, Allan',\n                  'ballotOrderNumber': 1,\n                  'party': \"Pauline Hanson's One Nation Queensland Division\",\n                  'partyCode': 'One Nation',\n                  'preferences': 302,\n                  'preferencesPercentage': '42.72%',\n                  'runningTotal': 1841},\n                 {'ballotName': 'MELLISH, Bart',\n                  'ballotOrderNumber': 3,\n                  'party': 'Australian Labor Party (State of Queensland)',\n                  'partyCode': 'Australian Labor Party',\n                  'preferences': 113,\n                  'preferencesPercentage': '15.98%',\n                  'runningTotal': 14101},\n                 {'ballotName': 'COOPER, Amanda',\n                  'ballotOrderNumber': 4,\n                  'party': 'Liberal National Party of Queensland',\n                  'partyCode': 'LNP',\n                  'preferences': 179,\n                  'preferencesPercentage': '25.32%',\n                  'runningTotal': 15875},\n                 {'ballotName': 'HAWKINS, Fiona',\n                  'ballotOrderNumber': 5,\n                  'party': 'Queensland Greens',\n                  'partyCode': 'The Greens',\n                  'preferences': 113,\n                  'preferencesPercentage': '15.98%',\n                  'runningTotal': 3930}]}"
  },
  {
    "objectID": "notebooks/qld-election-2024-pref-flows.html#downloading-all-data",
    "href": "notebooks/qld-election-2024-pref-flows.html#downloading-all-data",
    "title": "Visualising preference flows in 2024 QLD state elections",
    "section": "Downloading all data",
    "text": "Downloading all data\nNext, we want to dowload all the data and save that somewhere to avoid repeating the API calls.\nBefore doing that, lets also assign colours to the parties. These are based on the colours commonly associated with these parties. https://peo.gov.au/understand-our-parliament/your-questions-on-notice/questions/what-are-the-colours-of-the-australian-political-parties\nI’ve assigned unique colours to other parties whose colours I’m not aware of. And we also need colours for independents.\n\ncolours = {\n    \"ALP\": \"#FF0000\",\n    \"Family First\": \"#1CE6EF\",\n    \"KAP\": \"#8B0000\",\n    \"LCQP\": \"#788D66\",\n    \"LNP\": \"#0000FF\",\n    \"One Nation\": \"#FFA500\",\n    \"The Greens\": \"#00FF00\",\n    \"Animal Justice Party\": \"#885578\",\n    \"Libertarians\": \"#FF34FF\",\n}\n\n# For independent candidates\nother_colours = [\n    \"#000000\",\n    \"#FFFF00\",\n    \"#FAD09F\",\n    \"#FF8A9A\",\n    \"#D157A0\",\n    \"#FF4A46\",\n]\n\nBased on the structure of the results we saw above and also the requirements for this project, we will create three dataframes focusing on the first preferences, final result, and the distributions.\nWe’ll use pandas, particularly the json_normalize and the DataFrame.from_records - based on the JSON structure provided by the API.\n\nimport pandas as pd\n\nLet’s specify what keys we are interested in.\n\nexclusion_cols = [\n    \"exclusion\",\n    \"excludedCandidate\",\n    \"excludedCandidatePartyCode\",\n    \"excludedCandidateBallotOrder\",\n    \"votesDistributed\",\n]\npref_cols = [\n    \"ballotName\",\n    \"preferences\",\n    \"preferencePercentage\",\n    \"runningTotal\",\n    \"partyCode\",\n    \"ballotOrderNumber\",\n]\n\nWe’ll define a couple of methods to parse the data from the JSON.\nThe first method we’ll define is to parse the votes received by candidates in either the primary count or the final count. We have already seen the strucutre of this data above. One key difference between the primary and final counts is the keys used to denote the votes: primary and count respectively. We’ll get around this by rename the primary column to count (if it exists) in the dataframe.\n\ndef parse_candidate_votes(data):\n    \"\"\"Parse the votes received by each candidate in the `data`.\"\"\"\n    counts = pd.DataFrame.from_records(data, exclude=[\"party\"]).rename(\n        columns={\n            \"ballotName\": \"candidate\",\n            \"ballotOrderNumber\": \"ballotOrder\",\n            \"partyCode\": \"party\",\n            \"primary\": \"count\",  # rename 'primary' to 'count' if it exists\n        }\n    )\n    # Now we have a 'count' column irrespective of the data\n\n    # assign colours to the candidates based on their party\n    counts[\"colour\"] = counts[\"party\"].map(colours)\n\n    # independents without a party colour\n    no_colour = counts[\"colour\"].isna()\n    counts.loc[no_colour, [\"colour\"]] = other_colours[: no_colour.sum()]\n    return counts\n\nThe next method is to parse the preference distributions in each distribution round. This will take a list of distributions and return a dataframe.\n\ndef parse_distribution(data):\n    distribution = pd.json_normalize(data, \"preferences\", exclusion_cols)\n\n    # remove redundant columns\n    distribution = distribution.loc[\n        :, distribution.columns.isin(exclusion_cols + pref_cols)\n    ]\n\n    # rename columns\n    distribution = distribution.rename(\n        columns={\n            \"ballotName\": \"toCandidate\",\n            \"ballotOrderNumber\": \"toBallotOrder\",\n            \"partyCode\": \"toParty\",\n            \"runningTotal\": \"toRunningTotal\",\n            \"excludedCandidate\": \"fromCandidate\",\n            \"excludedCandidatePartyCode\": \"fromParty\",\n            \"excludedCandidateBallotOrder\": \"fromBallotOrder\",\n        }\n    )\n    return distribution\n\nNow, we’re ready to download the data.\n\nfirst_prefs, distributions, final_tallies = [], [], []\nfor electorate in [x[\"stub\"] for x in electorates]:\n    res = requests.get(prefs_url.substitute(electorate=electorate))\n    result = res.json()\n\n    # first preferences\n    first_pref = parse_candidate_votes(\n        result[\"preferenceDistributionDetails\"][\"primary\"]\n    )\n    first_pref[\"electorate\"] = electorate\n    first_pref = first_pref.sort_values(\"count\")\n    first_prefs.append(first_pref)\n\n    # final tally\n    final = parse_candidate_votes(result[\"candidates\"])\n    final[\"electorate\"] = electorate\n    final = final.sort_values(\"count\")\n    final_tallies.append(final)\n\n    # preference distribution\n    data = result[\"preferenceDistributionDetails\"][\"distributions\"]\n    distribution = parse_distribution(data)\n    distribution[\"electorate\"] = electorate  # add electorate information\n    distributions.append(distribution)"
  },
  {
    "objectID": "notebooks/qld-election-2024-pref-flows.html#tidy",
    "href": "notebooks/qld-election-2024-pref-flows.html#tidy",
    "title": "Visualising preference flows in 2024 QLD state elections",
    "section": "Tidy",
    "text": "Tidy\nLet’s tidy the data.\n\nConcatenate data for each electorate into a single dataframe\nSet appropriate data types\nRename ‘Australian Labor Party’ to ‘ALP’\nSet ‘IND’ as the party value for independents - it is currently an empty string\n\n\n# we'll concatenate all electorate data into one dataframe for each data type\ndistribution = pd.concat(distributions).set_index(\"electorate\")\nfirst_pref = pd.concat(first_prefs).set_index(\"electorate\")\nfinal_tally = pd.concat(final_tallies)\n\n# set appropriate data types for each dataframe\ndistribution = distribution.astype(\n    {\n        \"toBallotOrder\": \"uint8\",\n        \"preferences\": \"uint16\",\n        \"toRunningTotal\": \"uint16\",\n        \"exclusion\": \"uint8\",\n        \"fromBallotOrder\": \"uint8\",\n        \"votesDistributed\": \"uint16\",\n        \"toParty\": \"category\",\n        \"fromParty\": \"category\",\n    }\n)\n\nfirst_pref = first_pref.astype(\n    {\n        \"ballotOrder\": \"uint8\",\n        \"count\": \"uint16\",\n        \"party\": \"category\",\n        \"colour\": \"category\",\n    }\n)\n\nfinal_tally = final_tally.astype(\n    {\n        \"ballotOrder\": \"uint8\",\n        \"party\": \"category\",\n        \"count\": \"uint16\",\n        \"colour\": \"category\",\n    }\n)\n\n# rename Australian Labor Party to ALP\ndistribution[\"toParty\"] = distribution[\"toParty\"].cat.rename_categories(\n    {\"Australian Labor Party\": \"ALP\"}\n)\ndistribution[\"fromParty\"] = distribution[\"fromParty\"].cat.rename_categories(\n    {\"Australian Labor Party\": \"ALP\"}\n)\nfinal_tally[\"party\"] = final_tally[\"party\"].cat.rename_categories(\n    {\"Australian Labor Party\": \"ALP\"}\n)\nfirst_pref[\"party\"] = first_pref[\"party\"].cat.rename_categories(\n    {\"Australian Labor Party\": \"ALP\"}\n)\n\n# Change independent candidates' party from &lt;empty-string&gt; to \"Ind.\"\nIND = \"Ind.\"\n\ndistribution[\"toParty\"] = distribution[\"toParty\"].cat.rename_categories({\"\": IND})\ndistribution[\"fromParty\"] = distribution[\"fromParty\"].cat.rename_categories({\"\": IND})\n\nfinal_tally[\"party\"] = final_tally[\"party\"].cat.rename_categories({\"\": IND})\nfirst_pref[\"party\"] = first_pref[\"party\"].cat.rename_categories({\"\": IND})"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sandeep Dhakal's Jupyter notebooks",
    "section": "",
    "text": "Zonal statistics: mean elevation of brisbane suburbs\n\n\n\n\n\n\nGIS\n\n\nDEM\n\n\n\n\n\n\n\n\n\nApr 15, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nVisualising preference flows in 2024 QLD state elections\n\n\n\n\n\n\nsankey\n\n\nelections\n\n\n\n\n\n\n\n\n\nMar 10, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notebooks/brisbane-suburbs-mean-elevation.html",
    "href": "notebooks/brisbane-suburbs-mean-elevation.html",
    "title": "Zonal statistics: mean elevation of brisbane suburbs",
    "section": "",
    "text": "As part of my geospatial analysis journey and the mapping of various things in Brisbane, in this notebook I will look at the digital elevation data of Brisbane suburbs.\nI will tackle this as two sequential tasks:"
  },
  {
    "objectID": "notebooks/brisbane-suburbs-mean-elevation.html#clipping-to-brisbanes-geometry",
    "href": "notebooks/brisbane-suburbs-mean-elevation.html#clipping-to-brisbanes-geometry",
    "title": "Zonal statistics: mean elevation of brisbane suburbs",
    "section": "Clipping to Brisbane’s geometry",
    "text": "Clipping to Brisbane’s geometry\nNotice that since we only used the 4 geographical bounds to download the raster data, we will further need to mask it to Brisbane’s geographic boundary. We can get the mask using the dissolve method from geopandas. Let’s also filter by elevation above 0 meters, so we can focus on the land area.\n\n# shapely Polygon  to clip raster\n# use shapely polygon in clip method of rioxarray object to clip raster\ndem = dem.rio.clip(suburbs.dissolve().geometry)\n\n# while plotting, lets only show elevation higher than 0 metres above sea-level.\ndem.where(dem &gt; 0).plot(cmap=\"terrain\")\n\n\n\n\n\n\n\n\nWe can clearly see that most parts of Brisbane are low lying (under 100 metres above sea level) with north-western parts (such as England Creek, Lake Manchester, Mount Coot-tha, Enoggera Reservoir) with higher elevation.\nWe can also clip the data around the apparently low-lying parts to see the minute variations in elevation throughout the city, and the difference between the north-eastern and southern parts of the city.\n\nfrom shapely import Polygon\n\ntest_poly = [\n    Polygon(((152.975, -27.3), (152.975, -27.65), (153.2, -27.65), (153.2, -27.3)))\n]\nclipped_dem = dem.rio.clip(test_poly)\n\nfig, ax = plt.subplots()\nclipped_dem.where(clipped_dem &gt; 0).plot(cmap=\"terrain\", ax=ax)\nax.xaxis.set_major_locator(plt.MaxNLocator(5))\nplt.show()"
  }
]